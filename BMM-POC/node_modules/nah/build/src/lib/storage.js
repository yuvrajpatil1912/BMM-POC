"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const decompress = require("decompress");
const mkdirp = require("mkdirp");
const constants = require("./constants");
const templates = require("./templates");
function initialize() {
    mkdirp.sync(constants.STORAGE_VERSIONS);
    mkdirp.sync(constants.STORAGE_HOOKS);
    const postInstallHook = hook("post_install");
    if (!fs.existsSync(postInstallHook)) {
        fs.writeFileSync(postInstallHook, templates.hooks.post_install, "utf-8");
        fs.chmodSync(postInstallHook, "0755");
    }
}
exports.initialize = initialize;
function hook(name) {
    if (name === "post_install") {
        return path.join(constants.STORAGE_HOOKS, "post_install.sh");
    }
    throw new Error("Unknown hook.");
}
exports.hook = hook;
function split(text, char) {
    const pos = text.indexOf(char);
    if (pos === -1) {
        return [text];
    }
    return [text.substr(0, pos), text.substr(pos + 2)];
}
exports.split = split;
function versions() {
    return fs.readdirSync(constants.STORAGE_VERSIONS)
        .filter((ver) => {
        const p = path.join(constants.STORAGE_VERSIONS, ver);
        const stat = fs.statSync(p);
        return stat.isDirectory();
    })
        .map((ver) => {
        const [channel, versionName] = split(ver, "--");
        return {
            channel,
            full: `${channel}--${versionName}`,
            human: `${channel}/${versionName}`,
            path: path.resolve(constants.STORAGE_VERSIONS, ver),
            version: versionName,
        };
    })
        .sort()
        .reverse();
}
exports.versions = versions;
function version(ver) {
    const v = versions().find((c) => c.full === ver.full);
    return v ? v : null;
}
exports.version = version;
function which(ver) {
    const v = version(ver);
    if (v) {
        return v.path;
    }
    return null;
}
exports.which = which;
function current() {
    try {
        const p = fs.realpathSync(constants.STORAGE_CURRENT_VERSION);
        const [channel, versionName] = split(path.basename(p), "--");
        return {
            channel,
            full: `${channel}--${versionName}`,
            human: `${channel}/${versionName}`,
            path: p,
            version: versionName,
        };
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return null;
        }
        throw err;
    }
}
exports.current = current;
function makeCurrent(ver) {
    const p = which(ver);
    if (!p) {
        throw new Error(`Version "${ver.human}" not installed.`);
    }
    try {
        fs.unlinkSync(constants.STORAGE_CURRENT_VERSION);
    }
    catch (err) {
        if (err.code !== "ENOENT") {
            throw err;
        }
    }
    fs.symlinkSync(p, constants.STORAGE_CURRENT_VERSION, "junction");
}
exports.makeCurrent = makeCurrent;
function installVersion(ver, name, archive) {
    return decompress(archive, constants.STORAGE_VERSIONS).then(() => {
        const oldName = path.join(constants.STORAGE_VERSIONS, name);
        const newName = path.join(constants.STORAGE_VERSIONS, ver.full);
        return new Promise((resolve, reject) => {
            fs.rename(oldName, newName, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    });
}
exports.installVersion = installVersion;
//# sourceMappingURL=storage.js.map